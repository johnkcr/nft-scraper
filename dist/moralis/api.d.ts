/**
 * Moralis API
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 2
 *
 *
 * NOTE: This file is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the file manually.
 */
import { Configuration } from './configuration';
/**
 *
 * @export
 */
export declare const COLLECTION_FORMATS: {
    csv: string;
    ssv: string;
    tsv: string;
    pipes: string;
};
/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
    (url: string, init?: any): Promise<Response>;
}
/**
 *
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
    url: string;
    options: any;
}
/**
 *
 * @export
 * @class BaseAPI
 */
export declare class BaseAPI {
    protected basePath: string;
    protected fetch: FetchAPI;
    protected configuration: Configuration;
    constructor(configuration?: Configuration, basePath?: string, fetch?: FetchAPI);
}
/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export declare class RequiredError extends Error {
    field: string;
    name: 'RequiredError';
    constructor(field: string, msg?: string);
}
/**
 *
 * @export
 * @interface Block
 */
export interface Block {
    /**
     * The block timestamp
     * @type {string}
     * @memberof Block
     */
    timestamp: string;
    /**
     * The block number
     * @type {string}
     * @memberof Block
     */
    number: string;
    /**
     * The block hash
     * @type {string}
     * @memberof Block
     */
    hash: string;
    /**
     * The block hash of the parent block
     * @type {string}
     * @memberof Block
     */
    parentHash: string;
    /**
     * The nonce
     * @type {string}
     * @memberof Block
     */
    nonce: string;
    /**
     *
     * @type {string}
     * @memberof Block
     */
    sha3Uncles: string;
    /**
     *
     * @type {string}
     * @memberof Block
     */
    logsBloom: string;
    /**
     *
     * @type {string}
     * @memberof Block
     */
    transactionsRoot: string;
    /**
     *
     * @type {string}
     * @memberof Block
     */
    stateRoot: string;
    /**
     *
     * @type {string}
     * @memberof Block
     */
    receiptsRoot: string;
    /**
     * The address of the miner
     * @type {string}
     * @memberof Block
     */
    miner: string;
    /**
     * The difficulty of the block
     * @type {string}
     * @memberof Block
     */
    difficulty: string;
    /**
     * The total difficulty
     * @type {string}
     * @memberof Block
     */
    totalDifficulty: string;
    /**
     * The block size
     * @type {string}
     * @memberof Block
     */
    size: string;
    /**
     *
     * @type {string}
     * @memberof Block
     */
    extraData: string;
    /**
     * The gas limit
     * @type {string}
     * @memberof Block
     */
    gasLimit: string;
    /**
     * The gas used
     * @type {string}
     * @memberof Block
     */
    gasUsed: string;
    /**
     * The number of transactions in the block
     * @type {string}
     * @memberof Block
     */
    transactionCount: string;
    /**
     * The transactions in the block
     * @type {Array<BlockTransaction>}
     * @memberof Block
     */
    transactions: Array<BlockTransaction>;
}
/**
 *
 * @export
 * @interface BlockTransaction
 */
export interface BlockTransaction {
    /**
     * The hash of the transaction
     * @type {string}
     * @memberof BlockTransaction
     */
    hash: string;
    /**
     * The nonce
     * @type {string}
     * @memberof BlockTransaction
     */
    nonce: string;
    /**
     *
     * @type {string}
     * @memberof BlockTransaction
     */
    transactionIndex: string;
    /**
     * The from address
     * @type {string}
     * @memberof BlockTransaction
     */
    fromAddress: string;
    /**
     * The to address
     * @type {string}
     * @memberof BlockTransaction
     */
    toAddress: string;
    /**
     * The value sent
     * @type {string}
     * @memberof BlockTransaction
     */
    value: string;
    /**
     *
     * @type {string}
     * @memberof BlockTransaction
     */
    gas?: string;
    /**
     * The gas price
     * @type {string}
     * @memberof BlockTransaction
     */
    gasPrice: string;
    /**
     *
     * @type {string}
     * @memberof BlockTransaction
     */
    input: string;
    /**
     *
     * @type {string}
     * @memberof BlockTransaction
     */
    receiptCumulativeGasUsed: string;
    /**
     *
     * @type {string}
     * @memberof BlockTransaction
     */
    receiptGasUsed: string;
    /**
     *
     * @type {string}
     * @memberof BlockTransaction
     */
    receiptContractAddress?: string;
    /**
     *
     * @type {string}
     * @memberof BlockTransaction
     */
    receiptRoot?: string;
    /**
     *
     * @type {string}
     * @memberof BlockTransaction
     */
    receiptStatus: string;
    /**
     * The block timestamp
     * @type {string}
     * @memberof BlockTransaction
     */
    blockTimestamp: string;
    /**
     * The block number
     * @type {string}
     * @memberof BlockTransaction
     */
    blockNumber: string;
    /**
     * The hash of the block
     * @type {string}
     * @memberof BlockTransaction
     */
    blockHash: string;
    /**
     * The logs of the transaction
     * @type {Array<Log>}
     * @memberof BlockTransaction
     */
    logs: Array<Log>;
}
/**
 *
 * @export
 * @enum {string}
 */
export declare enum ChainList {
    Eth,
    _0x1,
    Ropsten,
    _0x3,
    Rinkeby,
    _0x4,
    Goerli,
    _0x5,
    Kovan,
    _0x2a,
    Polygon,
    _0x89,
    Mumbai,
    _0x13881,
    Bsc,
    _0x38,
    BscTestnet,
    _0x61
}
/**
 *
 * @export
 * @interface Erc20Allowance
 */
export interface Erc20Allowance {
    /**
     * The allowance
     * @type {string}
     * @memberof Erc20Allowance
     */
    allowance: string;
}
/**
 *
 * @export
 * @interface Erc20Metadata
 */
export interface Erc20Metadata {
    /**
     * The address of the token contract
     * @type {string}
     * @memberof Erc20Metadata
     */
    address: string;
    /**
     * The name of the token Contract
     * @type {string}
     * @memberof Erc20Metadata
     */
    name: string;
    /**
     * The symbol of the NFT contract
     * @type {string}
     * @memberof Erc20Metadata
     */
    symbol: string;
    /**
     * The number of decimals on of the token
     * @type {string}
     * @memberof Erc20Metadata
     */
    decimals: string;
    /**
     * The logo of the token
     * @type {string}
     * @memberof Erc20Metadata
     */
    logo?: string;
    /**
     * The logo hash
     * @type {string}
     * @memberof Erc20Metadata
     */
    logoHash?: string;
    /**
     * The thumbnail of the logo
     * @type {string}
     * @memberof Erc20Metadata
     */
    thumbnail?: string;
    /**
     *
     * @type {string}
     * @memberof Erc20Metadata
     */
    blockNumber?: string;
    /**
     *
     * @type {string}
     * @memberof Erc20Metadata
     */
    validated?: string;
}
/**
 *
 * @export
 * @interface Erc20Price
 */
export interface Erc20Price {
    /**
     *
     * @type {NativeErc20Price}
     * @memberof Erc20Price
     */
    nativePrice?: NativeErc20Price;
    /**
     * The price in USD for the token
     * @type {number}
     * @memberof Erc20Price
     */
    usdPrice: number;
    /**
     * The address of the exchange used to calculate the price
     * @type {string}
     * @memberof Erc20Price
     */
    exchangeAddress?: string;
    /**
     * The name of the exchange used for calculating the price
     * @type {string}
     * @memberof Erc20Price
     */
    exchangeName?: string;
}
/**
 *
 * @export
 * @interface Erc20TokenBalance
 */
export interface Erc20TokenBalance {
    /**
     * The address of the token contract
     * @type {string}
     * @memberof Erc20TokenBalance
     */
    tokenAddress: string;
    /**
     * The name of the token Contract
     * @type {string}
     * @memberof Erc20TokenBalance
     */
    name: string;
    /**
     * The symbol of the NFT contract
     * @type {string}
     * @memberof Erc20TokenBalance
     */
    symbol: string;
    /**
     * The logo of the token
     * @type {string}
     * @memberof Erc20TokenBalance
     */
    logo?: string;
    /**
     * The thumbnail of the logo
     * @type {string}
     * @memberof Erc20TokenBalance
     */
    thumbnail?: string;
    /**
     * The number of decimals on of the token
     * @type {string}
     * @memberof Erc20TokenBalance
     */
    decimals: string;
    /**
     * Timestamp of when the contract was last synced with the node
     * @type {string}
     * @memberof Erc20TokenBalance
     */
    balance: string;
}
/**
 *
 * @export
 * @interface Erc20Transaction
 */
export interface Erc20Transaction {
    /**
     * The transaction hash
     * @type {string}
     * @memberof Erc20Transaction
     */
    transactionHash: string;
    /**
     * The address of the token
     * @type {string}
     * @memberof Erc20Transaction
     */
    address: string;
    /**
     * The block timestamp
     * @type {string}
     * @memberof Erc20Transaction
     */
    blockTimestamp: string;
    /**
     * The block number
     * @type {string}
     * @memberof Erc20Transaction
     */
    blockNumber: string;
    /**
     * The block hash
     * @type {string}
     * @memberof Erc20Transaction
     */
    blockHash: string;
    /**
     * The recipient
     * @type {string}
     * @memberof Erc20Transaction
     */
    toAddress: string;
    /**
     * The sender
     * @type {string}
     * @memberof Erc20Transaction
     */
    fromAddress: string;
    /**
     * The value that was transfered (in wei)
     * @type {string}
     * @memberof Erc20Transaction
     */
    value: string;
}
/**
 *
 * @export
 * @interface Erc721Metadata
 */
export interface Erc721Metadata {
    /**
     * The name of the token Contract
     * @type {string}
     * @memberof Erc721Metadata
     */
    name: string;
    /**
     * The symbol of the NFT contract
     * @type {string}
     * @memberof Erc721Metadata
     */
    symbol: string;
    /**
     *
     * @type {string}
     * @memberof Erc721Metadata
     */
    tokenUri?: string;
}
/**
 *
 * @export
 * @interface HistoricalNftTransfer
 */
export interface HistoricalNftTransfer {
    /**
     * The transaction hash
     * @type {string}
     * @memberof HistoricalNftTransfer
     */
    transactionHash: string;
    /**
     * The address of the token
     * @type {string}
     * @memberof HistoricalNftTransfer
     */
    address: string;
    /**
     * The block timestamp
     * @type {string}
     * @memberof HistoricalNftTransfer
     */
    blockTimestamp: string;
    /**
     * The block number
     * @type {string}
     * @memberof HistoricalNftTransfer
     */
    blockNumber: string;
    /**
     * The block hash
     * @type {string}
     * @memberof HistoricalNftTransfer
     */
    blockHash: string;
    /**
     * The recipient
     * @type {string}
     * @memberof HistoricalNftTransfer
     */
    toAddress: string;
    /**
     * The sender
     * @type {string}
     * @memberof HistoricalNftTransfer
     */
    fromAddress: string;
    /**
     * The token ids of the tokens that were transfered
     * @type {Array<string>}
     * @memberof HistoricalNftTransfer
     */
    tokenIds: Array<string>;
    /**
     * The amounts that were transfered
     * @type {Array<string>}
     * @memberof HistoricalNftTransfer
     */
    amounts: Array<string>;
    /**
     * They contract type of the transfer
     * @type {string}
     * @memberof HistoricalNftTransfer
     */
    contractType: string;
}
/**
 *
 * @export
 * @interface Log
 */
export interface Log {
    /**
     *
     * @type {string}
     * @memberof Log
     */
    logIndex: string;
    /**
     * The hash of the transaction
     * @type {string}
     * @memberof Log
     */
    transactionHash: string;
    /**
     *
     * @type {string}
     * @memberof Log
     */
    transactionIndex: string;
    /**
     * The address of the contract
     * @type {string}
     * @memberof Log
     */
    address: string;
    /**
     * The data of the log
     * @type {string}
     * @memberof Log
     */
    data: string;
    /**
     *
     * @type {string}
     * @memberof Log
     */
    topic0: string;
    /**
     *
     * @type {string}
     * @memberof Log
     */
    topic1?: string;
    /**
     *
     * @type {string}
     * @memberof Log
     */
    topic2?: string;
    /**
     *
     * @type {string}
     * @memberof Log
     */
    topic3?: string;
    /**
     * The timestamp of the block
     * @type {string}
     * @memberof Log
     */
    blockTimestamp: string;
    /**
     * The block number
     * @type {string}
     * @memberof Log
     */
    blockNumber: string;
    /**
     * The hash of the block
     * @type {string}
     * @memberof Log
     */
    blockHash: string;
}
/**
 *
 * @export
 * @interface LogEvent
 */
export interface LogEvent {
    /**
     * The transaction hash
     * @type {string}
     * @memberof LogEvent
     */
    transactionHash: string;
    /**
     * The address of the contract
     * @type {string}
     * @memberof LogEvent
     */
    address: string;
    /**
     * The block timestamp
     * @type {string}
     * @memberof LogEvent
     */
    blockTimestamp: string;
    /**
     * The block number
     * @type {string}
     * @memberof LogEvent
     */
    blockNumber: string;
    /**
     * The block hash
     * @type {string}
     * @memberof LogEvent
     */
    blockHash: string;
    /**
     * The content of the event
     * @type {any}
     * @memberof LogEvent
     */
    data: any;
}
/**
 *
 * @export
 * @interface NativeBalance
 */
export interface NativeBalance {
    /**
     * The balance
     * @type {string}
     * @memberof NativeBalance
     */
    balance: string;
}
/**
 *
 * @export
 * @interface NativeErc20Price
 */
export interface NativeErc20Price {
    /**
     * The native price of the token
     * @type {string}
     * @memberof NativeErc20Price
     */
    value: string;
    /**
     * The number of decimals of the token
     * @type {number}
     * @memberof NativeErc20Price
     */
    decimals: number;
    /**
     * The Name of the token
     * @type {string}
     * @memberof NativeErc20Price
     */
    name: string;
    /**
     * The Symbol of the token
     * @type {string}
     * @memberof NativeErc20Price
     */
    symbol: string;
}
/**
 *
 * @export
 * @interface Nft
 */
export interface Nft {
    /**
     * The address of the contract of the NFT
     * @type {string}
     * @memberof Nft
     */
    tokenAddress: string;
    /**
     * The token id of the NFT
     * @type {string}
     * @memberof Nft
     */
    tokenId: string;
    /**
     * The type of NFT contract standard
     * @type {string}
     * @memberof Nft
     */
    contractType: string;
    /**
     * The uri to the metadata of the token
     * @type {string}
     * @memberof Nft
     */
    tokenUri?: string;
    /**
     * The metadata of the token
     * @type {string}
     * @memberof Nft
     */
    metadata?: string;
    /**
     * when the metadata was last updated
     * @type {string}
     * @memberof Nft
     */
    syncedAt?: string;
    /**
     * The number of this item the user owns (used by ERC1155)
     * @type {string}
     * @memberof Nft
     */
    amount?: string;
    /**
     * The name of the Token contract
     * @type {string}
     * @memberof Nft
     */
    name: string;
    /**
     * The symbol of the NFT contract
     * @type {string}
     * @memberof Nft
     */
    symbol: string;
}
/**
 *
 * @export
 * @interface NftCollection
 */
export interface NftCollection {
    /**
     * The total number of matches for this query
     * @type {number}
     * @memberof NftCollection
     */
    total?: number;
    /**
     * The page of the current result
     * @type {number}
     * @memberof NftCollection
     */
    page?: number;
    /**
     * The number of results per page
     * @type {number}
     * @memberof NftCollection
     */
    pageSize?: number;
    /**
     *
     * @type {Array<Nft>}
     * @memberof NftCollection
     */
    result?: Array<Nft>;
}
/**
 *
 * @export
 * @interface NftContractMetadata
 */
export interface NftContractMetadata {
    /**
     * The address of the token contract
     * @type {string}
     * @memberof NftContractMetadata
     */
    tokenAddress: string;
    /**
     * The name of the token Contract
     * @type {string}
     * @memberof NftContractMetadata
     */
    name: string;
    /**
     * The abi of the token Contract
     * @type {string}
     * @memberof NftContractMetadata
     */
    abi?: string;
    /**
     * value -1 if the contract does not support token_uri
     * @type {number}
     * @memberof NftContractMetadata
     */
    supportsTokenUri?: number;
    /**
     * Timestamp of when the contract was last synced with the node
     * @type {string}
     * @memberof NftContractMetadata
     */
    syncedAt?: string;
    /**
     * The symbol of the NFT contract
     * @type {string}
     * @memberof NftContractMetadata
     */
    symbol: string;
    /**
     * The type of NFT contract
     * @type {string}
     * @memberof NftContractMetadata
     */
    contractType: string;
}
/**
 *
 * @export
 * @interface NftContractMetadataCollection
 */
export interface NftContractMetadataCollection {
    /**
     * The total number of matches for this query
     * @type {number}
     * @memberof NftContractMetadataCollection
     */
    total: number;
    /**
     * The page of the current result
     * @type {number}
     * @memberof NftContractMetadataCollection
     */
    page: number;
    /**
     * The number of results per page
     * @type {number}
     * @memberof NftContractMetadataCollection
     */
    pageSize: number;
    /**
     *
     * @type {Array<NftContractMetadata>}
     * @memberof NftContractMetadataCollection
     */
    result: Array<NftContractMetadata>;
}
/**
 *
 * @export
 * @interface NftOwner
 */
export interface NftOwner {
    /**
     * The address of the contract of the NFT
     * @type {string}
     * @memberof NftOwner
     */
    tokenAddress: string;
    /**
     * The token id of the NFT
     * @type {string}
     * @memberof NftOwner
     */
    tokenId: string;
    /**
     * The type of NFT contract standard
     * @type {string}
     * @memberof NftOwner
     */
    contractType: string;
    /**
     * The address of the owner of the NFT
     * @type {string}
     * @memberof NftOwner
     */
    ownerOf: string;
    /**
     * The blocknumber when the amount or owner changed
     * @type {string}
     * @memberof NftOwner
     */
    blockNumber: string;
    /**
     * The blocknumber when the NFT was minted
     * @type {string}
     * @memberof NftOwner
     */
    blockNumberMinted: string;
    /**
     * The uri to the metadata of the token
     * @type {string}
     * @memberof NftOwner
     */
    tokenUri?: string;
    /**
     * The metadata of the token
     * @type {string}
     * @memberof NftOwner
     */
    metadata?: string;
    /**
     * when the metadata was last updated
     * @type {string}
     * @memberof NftOwner
     */
    syncedAt?: string;
    /**
     * The number of this item the user owns (used by ERC1155)
     * @type {string}
     * @memberof NftOwner
     */
    amount?: string;
    /**
     * The name of the Token contract
     * @type {string}
     * @memberof NftOwner
     */
    name: string;
    /**
     * The symbol of the NFT contract
     * @type {string}
     * @memberof NftOwner
     */
    symbol: string;
}
/**
 *
 * @export
 * @interface NftOwnerCollection
 */
export interface NftOwnerCollection {
    /**
     * The syncing status of the address [SYNCING/SYNCED]
     * @type {string}
     * @memberof NftOwnerCollection
     */
    status?: string;
    /**
     * The total number of matches for this query
     * @type {number}
     * @memberof NftOwnerCollection
     */
    total?: number;
    /**
     * The page of the current result
     * @type {number}
     * @memberof NftOwnerCollection
     */
    page?: number;
    /**
     * The number of results per page
     * @type {number}
     * @memberof NftOwnerCollection
     */
    pageSize?: number;
    /**
     *
     * @type {Array<NftOwner>}
     * @memberof NftOwnerCollection
     */
    result?: Array<NftOwner>;
}
/**
 *
 * @export
 * @interface NftTransfer
 */
export interface NftTransfer {
    /**
     * The address of the contract of the NFT
     * @type {string}
     * @memberof NftTransfer
     */
    tokenAddress: string;
    /**
     * The token id of the NFT
     * @type {string}
     * @memberof NftTransfer
     */
    tokenId: string;
    /**
     * The address that sent the NFT
     * @type {string}
     * @memberof NftTransfer
     */
    fromAddress?: string;
    /**
     * The address that recieved the NFT
     * @type {string}
     * @memberof NftTransfer
     */
    toAddress: string;
    /**
     * The number of tokens transferred
     * @type {string}
     * @memberof NftTransfer
     */
    amount?: string;
    /**
     * The type of NFT contract standard
     * @type {string}
     * @memberof NftTransfer
     */
    contractType: string;
    /**
     * The blocknumber of the transaction
     * @type {string}
     * @memberof NftTransfer
     */
    blockNumber: string;
    /**
     * The block timestamp
     * @type {string}
     * @memberof NftTransfer
     */
    blockTimestamp: string;
    /**
     * The block hash of the transaction
     * @type {string}
     * @memberof NftTransfer
     */
    blockHash: string;
    /**
     * The transaction hash
     * @type {string}
     * @memberof NftTransfer
     */
    transactionHash: string;
    /**
     * The transaction type
     * @type {string}
     * @memberof NftTransfer
     */
    transactionType?: string;
    /**
     * The transaction index
     * @type {string}
     * @memberof NftTransfer
     */
    transactionIndex?: string;
    /**
     * The log index
     * @type {number}
     * @memberof NftTransfer
     */
    logIndex: number;
}
/**
 *
 * @export
 * @interface NftTransferCollection
 */
export interface NftTransferCollection {
    /**
     * The total number of matches for this query
     * @type {number}
     * @memberof NftTransferCollection
     */
    total: number;
    /**
     * The page of the current result
     * @type {number}
     * @memberof NftTransferCollection
     */
    page: number;
    /**
     * The number of results per page
     * @type {number}
     * @memberof NftTransferCollection
     */
    pageSize: number;
    /**
     *
     * @type {Array<NftTransfer>}
     * @memberof NftTransferCollection
     */
    result: Array<NftTransfer>;
}
/**
 *
 * @export
 * @interface Resolve
 */
export interface Resolve {
    /**
     * Resolved domain address
     * @type {string}
     * @memberof Resolve
     */
    address: string;
}
/**
 *
 * @export
 * @interface Transaction
 */
export interface Transaction {
    /**
     * The hash of the transaction
     * @type {string}
     * @memberof Transaction
     */
    hash: string;
    /**
     * The nonce of the transaction
     * @type {string}
     * @memberof Transaction
     */
    nonce: string;
    /**
     * The transaction index
     * @type {string}
     * @memberof Transaction
     */
    transactionIndex: string;
    /**
     * The sender
     * @type {string}
     * @memberof Transaction
     */
    fromAddress: string;
    /**
     * The recipient
     * @type {string}
     * @memberof Transaction
     */
    toAddress: string;
    /**
     * The value that was transfered (in wei)
     * @type {string}
     * @memberof Transaction
     */
    value: string;
    /**
     * The gas of the transaction
     * @type {string}
     * @memberof Transaction
     */
    gas: string;
    /**
     * The gas price
     * @type {string}
     * @memberof Transaction
     */
    gasPrice: string;
    /**
     * The input
     * @type {string}
     * @memberof Transaction
     */
    input: string;
    /**
     * The receipt cumulative gas used
     * @type {string}
     * @memberof Transaction
     */
    receiptCumulativeGasUsed: string;
    /**
     * The receipt gas used
     * @type {string}
     * @memberof Transaction
     */
    receiptGasUsed: string;
    /**
     * The receipt contract address
     * @type {string}
     * @memberof Transaction
     */
    receiptContractAddress: string;
    /**
     * The receipt root
     * @type {string}
     * @memberof Transaction
     */
    receiptRoot: string;
    /**
     * The receipt status
     * @type {string}
     * @memberof Transaction
     */
    receiptStatus: string;
    /**
     * The block timestamp
     * @type {string}
     * @memberof Transaction
     */
    blockTimestamp: string;
    /**
     * The block number
     * @type {string}
     * @memberof Transaction
     */
    blockNumber: string;
    /**
     * The block hash
     * @type {string}
     * @memberof Transaction
     */
    blockHash: string;
}
/**
 *
 * @export
 * @interface TransactionCollection
 */
export interface TransactionCollection {
    /**
     * The total number of matches for this query
     * @type {number}
     * @memberof TransactionCollection
     */
    total?: number;
    /**
     * The page of the current result
     * @type {number}
     * @memberof TransactionCollection
     */
    page?: number;
    /**
     * The number of results per page
     * @type {number}
     * @memberof TransactionCollection
     */
    pageSize?: number;
    /**
     *
     * @type {Array<Transaction>}
     * @memberof TransactionCollection
     */
    result?: Array<Transaction>;
}
/**
 * AccountApi - fetch parameter creator
 * @export
 */
export declare const AccountApiFetchParamCreator: (configuration?: Configuration) => {
    /**
     * Gets NFT token transactions in descending order based on block number
     * @summary Gets NFT transfers of a ERC721 or ERC1155 token
     * @param {string} address address
     * @param {ChainList} [chain] The chain to query
     * @param {string} [subdomain] The subdomain of the moralis server to use (Only use when selecting local devchain as chain)
     * @param {string} [providerUrl] web3 provider url to user when using local dev chain
     * @param {number} [fromBlock] from_block
     * @param {number} [toBlock] to_block
     * @param {number} [offset] offset
     * @param {number} [limit] limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getHistoricalNFTTransfers(address: string, chain?: ChainList, subdomain?: string, providerUrl?: string, fromBlock?: number, toBlock?: number, offset?: number, limit?: number, options?: any): FetchArgs;
    /**
     * Gets the transfers of the tokens matching the given parameters
     * @summary Gets NFT transfers to and from a given address
     * @param {string} address The sender or recepient of the transfer
     * @param {ChainList} [chain] The chain to query
     * @param {string} [format] The format of the token id
     * @param {string} [direction] The transfer direction
     * @param {number} [offset] offset
     * @param {number} [limit] limit
     * @param {string} [order] The field(s) to order on and if it should be ordered in ascending or descending order. Specified by: fieldName1.order,fieldName2.order. Example 1: \&quot;token_address\&quot;, \&quot;token_address.ASC\&quot;, \&quot;token_address.DESC\&quot;, Example 2: \&quot;token_address and token_id\&quot;, \&quot;token_address.ASC,token_id.DESC\&quot;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getNFTTransfers(address: string, chain?: ChainList, format?: string, direction?: string, offset?: number, limit?: number, order?: string, options?: any): FetchArgs;
    /**
     * Gets NFTs owned by the given address * The response will include status [SYNCED/SYNCING] based on the contracts being indexed. * Use the token_address param to get results for a specific contract only * Note results will include all indexed NFTs * Any request which includes the token_address param will start the indexing process for that NFT collection the very first time it is requested
     * @summary Gets the NFTs owned by a given address
     * @param {string} address The owner of a given token
     * @param {ChainList} [chain] The chain to query
     * @param {string} [format] The format of the token id
     * @param {number} [offset] offset
     * @param {number} [limit] limit
     * @param {string} [order] The field(s) to order on and if it should be ordered in ascending or descending order. Specified by: fieldName1.order,fieldName2.order. Example 1: \&quot;name\&quot;, \&quot;name.ASC\&quot;, \&quot;name.DESC\&quot;, Example 2: \&quot;Name and Symbol\&quot;, \&quot;name.ASC,symbol.DESC\&quot;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getNFTs(address: string, chain?: ChainList, format?: string, offset?: number, limit?: number, order?: string, options?: any): FetchArgs;
    /**
     * Gets NFTs owned by the given address * Use the token_address param to get results for a specific contract only * Note results will include all indexed NFTs * Any request which includes the token_address param will start the indexing process for that NFT collection the very first time it is requested
     * @summary Gets the NFTs owned by a given address
     * @param {string} address The owner of a given token
     * @param {string} tokenAddress Address of the contract
     * @param {ChainList} [chain] The chain to query
     * @param {string} [format] The format of the token id
     * @param {number} [offset] offset
     * @param {number} [limit] limit
     * @param {string} [order] The field(s) to order on and if it should be ordered in ascending or descending order. Specified by: fieldName1.order,fieldName2.order. Example 1: \&quot;name\&quot;, \&quot;name.ASC\&quot;, \&quot;name.DESC\&quot;, Example 2: \&quot;Name and Symbol\&quot;, \&quot;name.ASC,symbol.DESC\&quot;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getNFTsForContract(address: string, tokenAddress: string, chain?: ChainList, format?: string, offset?: number, limit?: number, order?: string, options?: any): FetchArgs;
    /**
     * Gets native balance for a specific address
     * @summary Gets native balance for a specific address.
     * @param {string} address The address for which the native balance will be checked
     * @param {ChainList} [chain] The chain to query
     * @param {string} [providerUrl] web3 provider url to user when using local dev chain
     * @param {number} [toBlock] The block number on which the balances should be checked
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getNativeBalance(address: string, chain?: ChainList, providerUrl?: string, toBlock?: number, options?: any): FetchArgs;
    /**
     * Gets token balances for a specific address
     * @summary Gets token balances for a specific address.
     * @param {string} address The address for which token balances will be checked
     * @param {ChainList} [chain] The chain to query
     * @param {string} [subdomain] The subdomain of the moralis server to use (Only use when selecting local devchain as chain)
     * @param {number} [toBlock] The block number on which the balances should be checked
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTokenBalances(address: string, chain?: ChainList, subdomain?: string, toBlock?: number, options?: any): FetchArgs;
    /**
     * Gets ERC20 token transactions in descending order based on block number
     * @summary Gets erc 20 token transactions
     * @param {string} address address
     * @param {ChainList} [chain] The chain to query
     * @param {string} [subdomain] The subdomain of the moralis server to use (Only use when selecting local devchain as chain)
     * @param {number} [fromBlock] from_block
     * @param {number} [toBlock] to_block
     * @param {number} [offset] offset
     * @param {number} [limit] limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTokenTransfers(address: string, chain?: ChainList, subdomain?: string, fromBlock?: number, toBlock?: number, offset?: number, limit?: number, options?: any): FetchArgs;
    /**
     * Gets native transactions in descending order based on block number
     * @summary Gets native transactions
     * @param {string} address address
     * @param {ChainList} [chain] The chain to query
     * @param {string} [subdomain] The subdomain of the moralis server to use (Only use when selecting local devchain as chain)
     * @param {number} [fromBlock] from_block
     * @param {number} [toBlock] to_block
     * @param {number} [offset] offset
     * @param {number} [limit] limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTransactions(address: string, chain?: ChainList, subdomain?: string, fromBlock?: number, toBlock?: number, offset?: number, limit?: number, options?: any): FetchArgs;
};
/**
 * AccountApi - functional programming interface
 * @export
 */
export declare const AccountApiFp: (configuration?: Configuration) => {
    /**
     * Gets NFT token transactions in descending order based on block number
     * @summary Gets NFT transfers of a ERC721 or ERC1155 token
     * @param {string} address address
     * @param {ChainList} [chain] The chain to query
     * @param {string} [subdomain] The subdomain of the moralis server to use (Only use when selecting local devchain as chain)
     * @param {string} [providerUrl] web3 provider url to user when using local dev chain
     * @param {number} [fromBlock] from_block
     * @param {number} [toBlock] to_block
     * @param {number} [offset] offset
     * @param {number} [limit] limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getHistoricalNFTTransfers(address: string, chain?: ChainList, subdomain?: string, providerUrl?: string, fromBlock?: number, toBlock?: number, offset?: number, limit?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<HistoricalNftTransfer>>;
    /**
     * Gets the transfers of the tokens matching the given parameters
     * @summary Gets NFT transfers to and from a given address
     * @param {string} address The sender or recepient of the transfer
     * @param {ChainList} [chain] The chain to query
     * @param {string} [format] The format of the token id
     * @param {string} [direction] The transfer direction
     * @param {number} [offset] offset
     * @param {number} [limit] limit
     * @param {string} [order] The field(s) to order on and if it should be ordered in ascending or descending order. Specified by: fieldName1.order,fieldName2.order. Example 1: \&quot;token_address\&quot;, \&quot;token_address.ASC\&quot;, \&quot;token_address.DESC\&quot;, Example 2: \&quot;token_address and token_id\&quot;, \&quot;token_address.ASC,token_id.DESC\&quot;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getNFTTransfers(address: string, chain?: ChainList, format?: string, direction?: string, offset?: number, limit?: number, order?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<NftTransferCollection>;
    /**
     * Gets NFTs owned by the given address * The response will include status [SYNCED/SYNCING] based on the contracts being indexed. * Use the token_address param to get results for a specific contract only * Note results will include all indexed NFTs * Any request which includes the token_address param will start the indexing process for that NFT collection the very first time it is requested
     * @summary Gets the NFTs owned by a given address
     * @param {string} address The owner of a given token
     * @param {ChainList} [chain] The chain to query
     * @param {string} [format] The format of the token id
     * @param {number} [offset] offset
     * @param {number} [limit] limit
     * @param {string} [order] The field(s) to order on and if it should be ordered in ascending or descending order. Specified by: fieldName1.order,fieldName2.order. Example 1: \&quot;name\&quot;, \&quot;name.ASC\&quot;, \&quot;name.DESC\&quot;, Example 2: \&quot;Name and Symbol\&quot;, \&quot;name.ASC,symbol.DESC\&quot;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getNFTs(address: string, chain?: ChainList, format?: string, offset?: number, limit?: number, order?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<NftOwnerCollection>;
    /**
     * Gets NFTs owned by the given address * Use the token_address param to get results for a specific contract only * Note results will include all indexed NFTs * Any request which includes the token_address param will start the indexing process for that NFT collection the very first time it is requested
     * @summary Gets the NFTs owned by a given address
     * @param {string} address The owner of a given token
     * @param {string} tokenAddress Address of the contract
     * @param {ChainList} [chain] The chain to query
     * @param {string} [format] The format of the token id
     * @param {number} [offset] offset
     * @param {number} [limit] limit
     * @param {string} [order] The field(s) to order on and if it should be ordered in ascending or descending order. Specified by: fieldName1.order,fieldName2.order. Example 1: \&quot;name\&quot;, \&quot;name.ASC\&quot;, \&quot;name.DESC\&quot;, Example 2: \&quot;Name and Symbol\&quot;, \&quot;name.ASC,symbol.DESC\&quot;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getNFTsForContract(address: string, tokenAddress: string, chain?: ChainList, format?: string, offset?: number, limit?: number, order?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<NftOwnerCollection>;
    /**
     * Gets native balance for a specific address
     * @summary Gets native balance for a specific address.
     * @param {string} address The address for which the native balance will be checked
     * @param {ChainList} [chain] The chain to query
     * @param {string} [providerUrl] web3 provider url to user when using local dev chain
     * @param {number} [toBlock] The block number on which the balances should be checked
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getNativeBalance(address: string, chain?: ChainList, providerUrl?: string, toBlock?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<NativeBalance>;
    /**
     * Gets token balances for a specific address
     * @summary Gets token balances for a specific address.
     * @param {string} address The address for which token balances will be checked
     * @param {ChainList} [chain] The chain to query
     * @param {string} [subdomain] The subdomain of the moralis server to use (Only use when selecting local devchain as chain)
     * @param {number} [toBlock] The block number on which the balances should be checked
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTokenBalances(address: string, chain?: ChainList, subdomain?: string, toBlock?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Erc20TokenBalance>>;
    /**
     * Gets ERC20 token transactions in descending order based on block number
     * @summary Gets erc 20 token transactions
     * @param {string} address address
     * @param {ChainList} [chain] The chain to query
     * @param {string} [subdomain] The subdomain of the moralis server to use (Only use when selecting local devchain as chain)
     * @param {number} [fromBlock] from_block
     * @param {number} [toBlock] to_block
     * @param {number} [offset] offset
     * @param {number} [limit] limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTokenTransfers(address: string, chain?: ChainList, subdomain?: string, fromBlock?: number, toBlock?: number, offset?: number, limit?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Erc20Transaction>>;
    /**
     * Gets native transactions in descending order based on block number
     * @summary Gets native transactions
     * @param {string} address address
     * @param {ChainList} [chain] The chain to query
     * @param {string} [subdomain] The subdomain of the moralis server to use (Only use when selecting local devchain as chain)
     * @param {number} [fromBlock] from_block
     * @param {number} [toBlock] to_block
     * @param {number} [offset] offset
     * @param {number} [limit] limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTransactions(address: string, chain?: ChainList, subdomain?: string, fromBlock?: number, toBlock?: number, offset?: number, limit?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TransactionCollection>;
};
/**
 * AccountApi - factory interface
 * @export
 */
export declare const AccountApiFactory: (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) => {
    /**
     * Gets NFT token transactions in descending order based on block number
     * @summary Gets NFT transfers of a ERC721 or ERC1155 token
     * @param {string} address address
     * @param {ChainList} [chain] The chain to query
     * @param {string} [subdomain] The subdomain of the moralis server to use (Only use when selecting local devchain as chain)
     * @param {string} [providerUrl] web3 provider url to user when using local dev chain
     * @param {number} [fromBlock] from_block
     * @param {number} [toBlock] to_block
     * @param {number} [offset] offset
     * @param {number} [limit] limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getHistoricalNFTTransfers(address: string, chain?: ChainList, subdomain?: string, providerUrl?: string, fromBlock?: number, toBlock?: number, offset?: number, limit?: number, options?: any): Promise<HistoricalNftTransfer[]>;
    /**
     * Gets the transfers of the tokens matching the given parameters
     * @summary Gets NFT transfers to and from a given address
     * @param {string} address The sender or recepient of the transfer
     * @param {ChainList} [chain] The chain to query
     * @param {string} [format] The format of the token id
     * @param {string} [direction] The transfer direction
     * @param {number} [offset] offset
     * @param {number} [limit] limit
     * @param {string} [order] The field(s) to order on and if it should be ordered in ascending or descending order. Specified by: fieldName1.order,fieldName2.order. Example 1: \&quot;token_address\&quot;, \&quot;token_address.ASC\&quot;, \&quot;token_address.DESC\&quot;, Example 2: \&quot;token_address and token_id\&quot;, \&quot;token_address.ASC,token_id.DESC\&quot;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getNFTTransfers(address: string, chain?: ChainList, format?: string, direction?: string, offset?: number, limit?: number, order?: string, options?: any): Promise<NftTransferCollection>;
    /**
     * Gets NFTs owned by the given address * The response will include status [SYNCED/SYNCING] based on the contracts being indexed. * Use the token_address param to get results for a specific contract only * Note results will include all indexed NFTs * Any request which includes the token_address param will start the indexing process for that NFT collection the very first time it is requested
     * @summary Gets the NFTs owned by a given address
     * @param {string} address The owner of a given token
     * @param {ChainList} [chain] The chain to query
     * @param {string} [format] The format of the token id
     * @param {number} [offset] offset
     * @param {number} [limit] limit
     * @param {string} [order] The field(s) to order on and if it should be ordered in ascending or descending order. Specified by: fieldName1.order,fieldName2.order. Example 1: \&quot;name\&quot;, \&quot;name.ASC\&quot;, \&quot;name.DESC\&quot;, Example 2: \&quot;Name and Symbol\&quot;, \&quot;name.ASC,symbol.DESC\&quot;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getNFTs(address: string, chain?: ChainList, format?: string, offset?: number, limit?: number, order?: string, options?: any): Promise<NftOwnerCollection>;
    /**
     * Gets NFTs owned by the given address * Use the token_address param to get results for a specific contract only * Note results will include all indexed NFTs * Any request which includes the token_address param will start the indexing process for that NFT collection the very first time it is requested
     * @summary Gets the NFTs owned by a given address
     * @param {string} address The owner of a given token
     * @param {string} tokenAddress Address of the contract
     * @param {ChainList} [chain] The chain to query
     * @param {string} [format] The format of the token id
     * @param {number} [offset] offset
     * @param {number} [limit] limit
     * @param {string} [order] The field(s) to order on and if it should be ordered in ascending or descending order. Specified by: fieldName1.order,fieldName2.order. Example 1: \&quot;name\&quot;, \&quot;name.ASC\&quot;, \&quot;name.DESC\&quot;, Example 2: \&quot;Name and Symbol\&quot;, \&quot;name.ASC,symbol.DESC\&quot;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getNFTsForContract(address: string, tokenAddress: string, chain?: ChainList, format?: string, offset?: number, limit?: number, order?: string, options?: any): Promise<NftOwnerCollection>;
    /**
     * Gets native balance for a specific address
     * @summary Gets native balance for a specific address.
     * @param {string} address The address for which the native balance will be checked
     * @param {ChainList} [chain] The chain to query
     * @param {string} [providerUrl] web3 provider url to user when using local dev chain
     * @param {number} [toBlock] The block number on which the balances should be checked
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getNativeBalance(address: string, chain?: ChainList, providerUrl?: string, toBlock?: number, options?: any): Promise<NativeBalance>;
    /**
     * Gets token balances for a specific address
     * @summary Gets token balances for a specific address.
     * @param {string} address The address for which token balances will be checked
     * @param {ChainList} [chain] The chain to query
     * @param {string} [subdomain] The subdomain of the moralis server to use (Only use when selecting local devchain as chain)
     * @param {number} [toBlock] The block number on which the balances should be checked
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTokenBalances(address: string, chain?: ChainList, subdomain?: string, toBlock?: number, options?: any): Promise<Erc20TokenBalance[]>;
    /**
     * Gets ERC20 token transactions in descending order based on block number
     * @summary Gets erc 20 token transactions
     * @param {string} address address
     * @param {ChainList} [chain] The chain to query
     * @param {string} [subdomain] The subdomain of the moralis server to use (Only use when selecting local devchain as chain)
     * @param {number} [fromBlock] from_block
     * @param {number} [toBlock] to_block
     * @param {number} [offset] offset
     * @param {number} [limit] limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTokenTransfers(address: string, chain?: ChainList, subdomain?: string, fromBlock?: number, toBlock?: number, offset?: number, limit?: number, options?: any): Promise<Erc20Transaction[]>;
    /**
     * Gets native transactions in descending order based on block number
     * @summary Gets native transactions
     * @param {string} address address
     * @param {ChainList} [chain] The chain to query
     * @param {string} [subdomain] The subdomain of the moralis server to use (Only use when selecting local devchain as chain)
     * @param {number} [fromBlock] from_block
     * @param {number} [toBlock] to_block
     * @param {number} [offset] offset
     * @param {number} [limit] limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTransactions(address: string, chain?: ChainList, subdomain?: string, fromBlock?: number, toBlock?: number, offset?: number, limit?: number, options?: any): Promise<TransactionCollection>;
};
/**
 * AccountApi - object-oriented interface
 * @export
 * @class AccountApi
 * @extends {BaseAPI}
 */
export declare class AccountApi extends BaseAPI {
    /**
     * Gets NFT token transactions in descending order based on block number
     * @summary Gets NFT transfers of a ERC721 or ERC1155 token
     * @param {string} address address
     * @param {ChainList} [chain] The chain to query
     * @param {string} [subdomain] The subdomain of the moralis server to use (Only use when selecting local devchain as chain)
     * @param {string} [providerUrl] web3 provider url to user when using local dev chain
     * @param {number} [fromBlock] from_block
     * @param {number} [toBlock] to_block
     * @param {number} [offset] offset
     * @param {number} [limit] limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    getHistoricalNFTTransfers(address: string, chain?: ChainList, subdomain?: string, providerUrl?: string, fromBlock?: number, toBlock?: number, offset?: number, limit?: number, options?: any): Promise<HistoricalNftTransfer[]>;
    /**
     * Gets the transfers of the tokens matching the given parameters
     * @summary Gets NFT transfers to and from a given address
     * @param {string} address The sender or recepient of the transfer
     * @param {ChainList} [chain] The chain to query
     * @param {string} [format] The format of the token id
     * @param {string} [direction] The transfer direction
     * @param {number} [offset] offset
     * @param {number} [limit] limit
     * @param {string} [order] The field(s) to order on and if it should be ordered in ascending or descending order. Specified by: fieldName1.order,fieldName2.order. Example 1: \&quot;token_address\&quot;, \&quot;token_address.ASC\&quot;, \&quot;token_address.DESC\&quot;, Example 2: \&quot;token_address and token_id\&quot;, \&quot;token_address.ASC,token_id.DESC\&quot;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    getNFTTransfers(address: string, chain?: ChainList, format?: string, direction?: string, offset?: number, limit?: number, order?: string, options?: any): Promise<NftTransferCollection>;
    /**
     * Gets NFTs owned by the given address * The response will include status [SYNCED/SYNCING] based on the contracts being indexed. * Use the token_address param to get results for a specific contract only * Note results will include all indexed NFTs * Any request which includes the token_address param will start the indexing process for that NFT collection the very first time it is requested
     * @summary Gets the NFTs owned by a given address
     * @param {string} address The owner of a given token
     * @param {ChainList} [chain] The chain to query
     * @param {string} [format] The format of the token id
     * @param {number} [offset] offset
     * @param {number} [limit] limit
     * @param {string} [order] The field(s) to order on and if it should be ordered in ascending or descending order. Specified by: fieldName1.order,fieldName2.order. Example 1: \&quot;name\&quot;, \&quot;name.ASC\&quot;, \&quot;name.DESC\&quot;, Example 2: \&quot;Name and Symbol\&quot;, \&quot;name.ASC,symbol.DESC\&quot;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    getNFTs(address: string, chain?: ChainList, format?: string, offset?: number, limit?: number, order?: string, options?: any): Promise<NftOwnerCollection>;
    /**
     * Gets NFTs owned by the given address * Use the token_address param to get results for a specific contract only * Note results will include all indexed NFTs * Any request which includes the token_address param will start the indexing process for that NFT collection the very first time it is requested
     * @summary Gets the NFTs owned by a given address
     * @param {string} address The owner of a given token
     * @param {string} tokenAddress Address of the contract
     * @param {ChainList} [chain] The chain to query
     * @param {string} [format] The format of the token id
     * @param {number} [offset] offset
     * @param {number} [limit] limit
     * @param {string} [order] The field(s) to order on and if it should be ordered in ascending or descending order. Specified by: fieldName1.order,fieldName2.order. Example 1: \&quot;name\&quot;, \&quot;name.ASC\&quot;, \&quot;name.DESC\&quot;, Example 2: \&quot;Name and Symbol\&quot;, \&quot;name.ASC,symbol.DESC\&quot;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    getNFTsForContract(address: string, tokenAddress: string, chain?: ChainList, format?: string, offset?: number, limit?: number, order?: string, options?: any): Promise<NftOwnerCollection>;
    /**
     * Gets native balance for a specific address
     * @summary Gets native balance for a specific address.
     * @param {string} address The address for which the native balance will be checked
     * @param {ChainList} [chain] The chain to query
     * @param {string} [providerUrl] web3 provider url to user when using local dev chain
     * @param {number} [toBlock] The block number on which the balances should be checked
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    getNativeBalance(address: string, chain?: ChainList, providerUrl?: string, toBlock?: number, options?: any): Promise<NativeBalance>;
    /**
     * Gets token balances for a specific address
     * @summary Gets token balances for a specific address.
     * @param {string} address The address for which token balances will be checked
     * @param {ChainList} [chain] The chain to query
     * @param {string} [subdomain] The subdomain of the moralis server to use (Only use when selecting local devchain as chain)
     * @param {number} [toBlock] The block number on which the balances should be checked
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    getTokenBalances(address: string, chain?: ChainList, subdomain?: string, toBlock?: number, options?: any): Promise<Erc20TokenBalance[]>;
    /**
     * Gets ERC20 token transactions in descending order based on block number
     * @summary Gets erc 20 token transactions
     * @param {string} address address
     * @param {ChainList} [chain] The chain to query
     * @param {string} [subdomain] The subdomain of the moralis server to use (Only use when selecting local devchain as chain)
     * @param {number} [fromBlock] from_block
     * @param {number} [toBlock] to_block
     * @param {number} [offset] offset
     * @param {number} [limit] limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    getTokenTransfers(address: string, chain?: ChainList, subdomain?: string, fromBlock?: number, toBlock?: number, offset?: number, limit?: number, options?: any): Promise<Erc20Transaction[]>;
    /**
     * Gets native transactions in descending order based on block number
     * @summary Gets native transactions
     * @param {string} address address
     * @param {ChainList} [chain] The chain to query
     * @param {string} [subdomain] The subdomain of the moralis server to use (Only use when selecting local devchain as chain)
     * @param {number} [fromBlock] from_block
     * @param {number} [toBlock] to_block
     * @param {number} [offset] offset
     * @param {number} [limit] limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    getTransactions(address: string, chain?: ChainList, subdomain?: string, fromBlock?: number, toBlock?: number, offset?: number, limit?: number, options?: any): Promise<TransactionCollection>;
}
/**
 * NativeApi - fetch parameter creator
 * @export
 */
export declare const NativeApiFetchParamCreator: (configuration?: Configuration) => {
    /**
     * Gets the contents of a block by block hash
     * @summary Gets block contents by block hash
     * @param {string} blockNumberOrHash The block hash or block number
     * @param {ChainList} [chain] The chain to query
     * @param {string} [subdomain] The subdomain of the moralis server to use (Only use when selecting local devchain as chain)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBlock(blockNumberOrHash: string, chain?: ChainList, subdomain?: string, options?: any): FetchArgs;
    /**
     * Gets events in descending order based on block number
     * @summary Gets events by topic
     * @param {string} address address
     * @param {string} topic The topic of the event
     * @param {any} [body] ABI of the specific event
     * @param {ChainList} [chain] The chain to query
     * @param {string} [subdomain] The subdomain of the moralis server to use (Only use when selecting local devchain as chain)
     * @param {string} [providerUrl] web3 provider url to user when using local dev chain
     * @param {number} [fromBlock] from_block
     * @param {number} [toBlock] to_block
     * @param {number} [offset] offset
     * @param {number} [limit] limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getContractEvents(address: string, topic: string, body?: any, chain?: ChainList, subdomain?: string, providerUrl?: string, fromBlock?: number, toBlock?: number, offset?: number, limit?: number, options?: any): FetchArgs;
    /**
     * Gets the contents of a block transaction by hash
     * @summary Gets block contents by block hash
     * @param {string} transactionHash The transaction hash
     * @param {ChainList} [chain] The chain to query
     * @param {string} [subdomain] The subdomain of the moralis server to use (Only use when selecting local devchain as chain)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTransaction(transactionHash: string, chain?: ChainList, subdomain?: string, options?: any): FetchArgs;
    /**
     * Runs a given function of a contract abi and returns readonly data
     * @summary Runs a function of a contract abi
     * @param {any} body Optional description in *Markdown*
     * @param {string} address address
     * @param {string} functionName function_name
     * @param {ChainList} [chain] The chain to query
     * @param {string} [subdomain] The subdomain of the moralis server to use (Only use when selecting local devchain as chain)
     * @param {string} [providerUrl] web3 provider url to user when using local dev chain
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runContractFunction(body: any, address: string, functionName: string, chain?: ChainList, subdomain?: string, providerUrl?: string, options?: any): FetchArgs;
};
/**
 * NativeApi - functional programming interface
 * @export
 */
export declare const NativeApiFp: (configuration?: Configuration) => {
    /**
     * Gets the contents of a block by block hash
     * @summary Gets block contents by block hash
     * @param {string} blockNumberOrHash The block hash or block number
     * @param {ChainList} [chain] The chain to query
     * @param {string} [subdomain] The subdomain of the moralis server to use (Only use when selecting local devchain as chain)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBlock(blockNumberOrHash: string, chain?: ChainList, subdomain?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Block>;
    /**
     * Gets events in descending order based on block number
     * @summary Gets events by topic
     * @param {string} address address
     * @param {string} topic The topic of the event
     * @param {any} [body] ABI of the specific event
     * @param {ChainList} [chain] The chain to query
     * @param {string} [subdomain] The subdomain of the moralis server to use (Only use when selecting local devchain as chain)
     * @param {string} [providerUrl] web3 provider url to user when using local dev chain
     * @param {number} [fromBlock] from_block
     * @param {number} [toBlock] to_block
     * @param {number} [offset] offset
     * @param {number} [limit] limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getContractEvents(address: string, topic: string, body?: any, chain?: ChainList, subdomain?: string, providerUrl?: string, fromBlock?: number, toBlock?: number, offset?: number, limit?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<LogEvent>>;
    /**
     * Gets the contents of a block transaction by hash
     * @summary Gets block contents by block hash
     * @param {string} transactionHash The transaction hash
     * @param {ChainList} [chain] The chain to query
     * @param {string} [subdomain] The subdomain of the moralis server to use (Only use when selecting local devchain as chain)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTransaction(transactionHash: string, chain?: ChainList, subdomain?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<BlockTransaction>;
    /**
     * Runs a given function of a contract abi and returns readonly data
     * @summary Runs a function of a contract abi
     * @param {any} body Optional description in *Markdown*
     * @param {string} address address
     * @param {string} functionName function_name
     * @param {ChainList} [chain] The chain to query
     * @param {string} [subdomain] The subdomain of the moralis server to use (Only use when selecting local devchain as chain)
     * @param {string} [providerUrl] web3 provider url to user when using local dev chain
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runContractFunction(body: any, address: string, functionName: string, chain?: ChainList, subdomain?: string, providerUrl?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string>;
};
/**
 * NativeApi - factory interface
 * @export
 */
export declare const NativeApiFactory: (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) => {
    /**
     * Gets the contents of a block by block hash
     * @summary Gets block contents by block hash
     * @param {string} blockNumberOrHash The block hash or block number
     * @param {ChainList} [chain] The chain to query
     * @param {string} [subdomain] The subdomain of the moralis server to use (Only use when selecting local devchain as chain)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBlock(blockNumberOrHash: string, chain?: ChainList, subdomain?: string, options?: any): Promise<Block>;
    /**
     * Gets events in descending order based on block number
     * @summary Gets events by topic
     * @param {string} address address
     * @param {string} topic The topic of the event
     * @param {any} [body] ABI of the specific event
     * @param {ChainList} [chain] The chain to query
     * @param {string} [subdomain] The subdomain of the moralis server to use (Only use when selecting local devchain as chain)
     * @param {string} [providerUrl] web3 provider url to user when using local dev chain
     * @param {number} [fromBlock] from_block
     * @param {number} [toBlock] to_block
     * @param {number} [offset] offset
     * @param {number} [limit] limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getContractEvents(address: string, topic: string, body?: any, chain?: ChainList, subdomain?: string, providerUrl?: string, fromBlock?: number, toBlock?: number, offset?: number, limit?: number, options?: any): Promise<LogEvent[]>;
    /**
     * Gets the contents of a block transaction by hash
     * @summary Gets block contents by block hash
     * @param {string} transactionHash The transaction hash
     * @param {ChainList} [chain] The chain to query
     * @param {string} [subdomain] The subdomain of the moralis server to use (Only use when selecting local devchain as chain)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTransaction(transactionHash: string, chain?: ChainList, subdomain?: string, options?: any): Promise<BlockTransaction>;
    /**
     * Runs a given function of a contract abi and returns readonly data
     * @summary Runs a function of a contract abi
     * @param {any} body Optional description in *Markdown*
     * @param {string} address address
     * @param {string} functionName function_name
     * @param {ChainList} [chain] The chain to query
     * @param {string} [subdomain] The subdomain of the moralis server to use (Only use when selecting local devchain as chain)
     * @param {string} [providerUrl] web3 provider url to user when using local dev chain
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runContractFunction(body: any, address: string, functionName: string, chain?: ChainList, subdomain?: string, providerUrl?: string, options?: any): Promise<string>;
};
/**
 * NativeApi - object-oriented interface
 * @export
 * @class NativeApi
 * @extends {BaseAPI}
 */
export declare class NativeApi extends BaseAPI {
    /**
     * Gets the contents of a block by block hash
     * @summary Gets block contents by block hash
     * @param {string} blockNumberOrHash The block hash or block number
     * @param {ChainList} [chain] The chain to query
     * @param {string} [subdomain] The subdomain of the moralis server to use (Only use when selecting local devchain as chain)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NativeApi
     */
    getBlock(blockNumberOrHash: string, chain?: ChainList, subdomain?: string, options?: any): Promise<Block>;
    /**
     * Gets events in descending order based on block number
     * @summary Gets events by topic
     * @param {string} address address
     * @param {string} topic The topic of the event
     * @param {any} [body] ABI of the specific event
     * @param {ChainList} [chain] The chain to query
     * @param {string} [subdomain] The subdomain of the moralis server to use (Only use when selecting local devchain as chain)
     * @param {string} [providerUrl] web3 provider url to user when using local dev chain
     * @param {number} [fromBlock] from_block
     * @param {number} [toBlock] to_block
     * @param {number} [offset] offset
     * @param {number} [limit] limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NativeApi
     */
    getContractEvents(address: string, topic: string, body?: any, chain?: ChainList, subdomain?: string, providerUrl?: string, fromBlock?: number, toBlock?: number, offset?: number, limit?: number, options?: any): Promise<LogEvent[]>;
    /**
     * Gets the contents of a block transaction by hash
     * @summary Gets block contents by block hash
     * @param {string} transactionHash The transaction hash
     * @param {ChainList} [chain] The chain to query
     * @param {string} [subdomain] The subdomain of the moralis server to use (Only use when selecting local devchain as chain)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NativeApi
     */
    getTransaction(transactionHash: string, chain?: ChainList, subdomain?: string, options?: any): Promise<BlockTransaction>;
    /**
     * Runs a given function of a contract abi and returns readonly data
     * @summary Runs a function of a contract abi
     * @param {any} body Optional description in *Markdown*
     * @param {string} address address
     * @param {string} functionName function_name
     * @param {ChainList} [chain] The chain to query
     * @param {string} [subdomain] The subdomain of the moralis server to use (Only use when selecting local devchain as chain)
     * @param {string} [providerUrl] web3 provider url to user when using local dev chain
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NativeApi
     */
    runContractFunction(body: any, address: string, functionName: string, chain?: ChainList, subdomain?: string, providerUrl?: string, options?: any): Promise<string>;
}
/**
 * ResolveApi - fetch parameter creator
 * @export
 */
export declare const ResolveApiFetchParamCreator: (configuration?: Configuration) => {
    /**
     * Resolves an Unstoppable domain and returns the address
     * @summary Resolves an Unstoppable domain and returns the address
     * @param {string} domain Domain to be resolved
     * @param {string} [currency] The currency to query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    resolveDomain(domain: string, currency?: string, options?: any): FetchArgs;
};
/**
 * ResolveApi - functional programming interface
 * @export
 */
export declare const ResolveApiFp: (configuration?: Configuration) => {
    /**
     * Resolves an Unstoppable domain and returns the address
     * @summary Resolves an Unstoppable domain and returns the address
     * @param {string} domain Domain to be resolved
     * @param {string} [currency] The currency to query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    resolveDomain(domain: string, currency?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Resolve>;
};
/**
 * ResolveApi - factory interface
 * @export
 */
export declare const ResolveApiFactory: (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) => {
    /**
     * Resolves an Unstoppable domain and returns the address
     * @summary Resolves an Unstoppable domain and returns the address
     * @param {string} domain Domain to be resolved
     * @param {string} [currency] The currency to query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    resolveDomain(domain: string, currency?: string, options?: any): Promise<Resolve>;
};
/**
 * ResolveApi - object-oriented interface
 * @export
 * @class ResolveApi
 * @extends {BaseAPI}
 */
export declare class ResolveApi extends BaseAPI {
    /**
     * Resolves an Unstoppable domain and returns the address
     * @summary Resolves an Unstoppable domain and returns the address
     * @param {string} domain Domain to be resolved
     * @param {string} [currency] The currency to query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResolveApi
     */
    resolveDomain(domain: string, currency?: string, options?: any): Promise<Resolve>;
}
/**
 * TokenApi - fetch parameter creator
 * @export
 */
export declare const TokenApiFetchParamCreator: (configuration?: Configuration) => {
    /**
     * Gets data, including metadata (where available), for all token ids for the given contract address. * Results are sorted by the block the token id was minted (descending) and limited to 100 per page by default * Requests for contract addresses not yet indexed will automatically start the indexing process for that NFT collection
     * @summary Retrieves the unique NFTs inside a given contract
     * @param {string} address Address of the contract
     * @param {ChainList} [chain] The chain to query
     * @param {string} [format] The format of the token id
     * @param {number} [offset] offset
     * @param {number} [limit] limit
     * @param {string} [order] If the order should be Ascending or Descending based on the blocknumber on which the NFT was minted. Allowed values: \&quot;ASC\&quot;, \&quot;DESC\&quot;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllTokenIds(address: string, chain?: ChainList, format?: string, offset?: number, limit?: number, order?: string, options?: any): FetchArgs;
    /**
     * Gets the transfers of the tokens matching the given parameters
     * @summary Gets NFT transfers of a given contract
     * @param {string} address Address of the contract
     * @param {ChainList} [chain] The chain to query
     * @param {string} [format] The format of the token id
     * @param {number} [offset] offset
     * @param {number} [limit] limit
     * @param {string} [order] The field(s) to order on and if it should be ordered in ascending or descending order. Specified by: fieldName1.order,fieldName2.order. Example 1: \&quot;block_number\&quot;, \&quot;block_number.ASC\&quot;, \&quot;block_number.DESC\&quot;, Example 2: \&quot;block_number and contract_type\&quot;, \&quot;block_number.ASC,contract_type.DESC\&quot;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getContractNFTTransfers(address: string, chain?: ChainList, format?: string, offset?: number, limit?: number, order?: string, options?: any): FetchArgs;
    /**
     * Gets the contract level metadata (name, symbol, base token uri) for the given contract * Requests for contract addresses not yet indexed will automatically start the indexing process for that NFT collection
     * @summary Gets the global metadata for a given contract
     * @param {string} address Address of the contract
     * @param {ChainList} [chain] The chain to query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getNFTMetadata(address: string, chain?: ChainList, options?: any): FetchArgs;
    /**
     * Gets all owners of NFT items within a given contract collection * Use after /nft/contract/{token_address} to find out who owns each token id in a collection * Make sure to include a sort parm on a column like block_number_minted for consistent pagination results * Requests for contract addresses not yet indexed will automatically start the indexing process for that NFT collection
     * @summary Gets the owners of the NFTs of a given contract
     * @param {string} address Address of the contract
     * @param {ChainList} [chain] The chain to query
     * @param {string} [format] The format of the token id
     * @param {number} [offset] offset
     * @param {number} [limit] limit
     * @param {string} [order] The field(s) to order on and if it should be ordered in ascending or descending order. Specified by: fieldName1.order,fieldName2.order. Example 1: \&quot;name\&quot;, \&quot;name.ASC\&quot;, \&quot;name.DESC\&quot;, Example 2: \&quot;Name and Symbol\&quot;, \&quot;name.ASC,symbol.DESC\&quot;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getNFTOwners(address: string, chain?: ChainList, format?: string, offset?: number, limit?: number, order?: string, options?: any): FetchArgs;
    /**
     * Gets the amount which the spender is allowed to withdraw from the spender
     * @summary Gets the amount which the spender is allowed to withdraw from the owner.
     * @param {string} address The address of the token contract
     * @param {string} ownerAddress The address of the token owner
     * @param {string} spenderAddress The address of the token spender
     * @param {ChainList} [chain] The chain to query
     * @param {string} [providerUrl] web3 provider url to user when using local dev chain
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTokenAllowance(address: string, ownerAddress: string, spenderAddress: string, chain?: ChainList, providerUrl?: string, options?: any): FetchArgs;
    /**
     * Gets data, including metadata (where available), for the given token id of the given contract address. * Requests for contract addresses not yet indexed will automatically start the indexing process for that NFT collection
     * @summary Gets the NFT with the given id of a given contract
     * @param {string} address Address of the contract
     * @param {string} tokenId The id of the token
     * @param {ChainList} [chain] The chain to query
     * @param {string} [format] The format of the token id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTokenIdMetadata(address: string, tokenId: string, chain?: ChainList, format?: string, options?: any): FetchArgs;
    /**
     * Gets all owners of NFT items within a given contract collection * Use after /nft/contract/{token_address} to find out who owns each token id in a collection * Make sure to include a sort parm on a column like block_number_minted for consistent pagination results * Requests for contract addresses not yet indexed will automatically start the indexing process for that NFT collection
     * @summary Gets the owners of NFTs for a given contract
     * @param {string} address Address of the contract
     * @param {string} tokenId The id of the token
     * @param {ChainList} [chain] The chain to query
     * @param {string} [format] The format of the token id
     * @param {number} [offset] offset
     * @param {number} [limit] limit
     * @param {string} [order] The field(s) to order on and if it should be ordered in ascending or descending order. Specified by: fieldName1.order,fieldName2.order. Example 1: \&quot;name\&quot;, \&quot;name.ASC\&quot;, \&quot;name.DESC\&quot;, Example 2: \&quot;Name and Symbol\&quot;, \&quot;name.ASC,symbol.DESC\&quot;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTokenIdOwners(address: string, tokenId: string, chain?: ChainList, format?: string, offset?: number, limit?: number, order?: string, options?: any): FetchArgs;
    /**
     * Returns metadata (name, symbol, decimals, logo) for a given token contract address.
     * @summary Gets token metadata
     * @param {Array<string>} addresses The addresses to get metadata for
     * @param {ChainList} [chain] The chain to query
     * @param {string} [subdomain] The subdomain of the moralis server to use (Only use when selecting local devchain as chain)
     * @param {string} [providerUrl] web3 provider url to user when using local dev chain
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTokenMetadata(addresses: Array<string>, chain?: ChainList, subdomain?: string, providerUrl?: string, options?: any): FetchArgs;
    /**
     * Returns metadata (name, symbol, decimals, logo) for a given token contract address.
     * @summary Gets token metadata
     * @param {Array<string>} symbols The symbols to get metadata for
     * @param {ChainList} [chain] The chain to query
     * @param {string} [subdomain] The subdomain of the moralis server to use (Only use when selecting local devchain as chain)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTokenMetadataBySymbol(symbols: Array<string>, chain?: ChainList, subdomain?: string, options?: any): FetchArgs;
    /**
     * Returns the price nominated in the native token and usd for a given token contract address.
     * @summary Gets token price
     * @param {string} address The address of the token contract
     * @param {ChainList} [chain] The chain to query
     * @param {string} [providerUrl] web3 provider url to user when using local dev chain
     * @param {string} [exchange] The factory name or address of the token exchange
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTokenPrice(address: string, chain?: ChainList, providerUrl?: string, exchange?: string, options?: any): FetchArgs;
    /**
     * Gets the transfers of the tokens matching the given parameters
     * @summary Gets NFT transfers of a given contract
     * @param {string} address Address of the contract
     * @param {string} tokenId The id of the token
     * @param {ChainList} [chain] The chain to query
     * @param {string} [format] The format of the token id
     * @param {number} [offset] offset
     * @param {number} [limit] limit
     * @param {string} [order] The field(s) to order on and if it should be ordered in ascending or descending order. Specified by: fieldName1.order,fieldName2.order. Example 1: \&quot;block_number\&quot;, \&quot;block_number.ASC\&quot;, \&quot;block_number.DESC\&quot;, Example 2: \&quot;block_number and contract_type\&quot;, \&quot;block_number.ASC,contract_type.DESC\&quot;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getWalletTokenIdTransfers(address: string, tokenId: string, chain?: ChainList, format?: string, offset?: number, limit?: number, order?: string, options?: any): FetchArgs;
};
/**
 * TokenApi - functional programming interface
 * @export
 */
export declare const TokenApiFp: (configuration?: Configuration) => {
    /**
     * Gets data, including metadata (where available), for all token ids for the given contract address. * Results are sorted by the block the token id was minted (descending) and limited to 100 per page by default * Requests for contract addresses not yet indexed will automatically start the indexing process for that NFT collection
     * @summary Retrieves the unique NFTs inside a given contract
     * @param {string} address Address of the contract
     * @param {ChainList} [chain] The chain to query
     * @param {string} [format] The format of the token id
     * @param {number} [offset] offset
     * @param {number} [limit] limit
     * @param {string} [order] If the order should be Ascending or Descending based on the blocknumber on which the NFT was minted. Allowed values: \&quot;ASC\&quot;, \&quot;DESC\&quot;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllTokenIds(address: string, chain?: ChainList, format?: string, offset?: number, limit?: number, order?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<NftCollection>;
    /**
     * Gets the transfers of the tokens matching the given parameters
     * @summary Gets NFT transfers of a given contract
     * @param {string} address Address of the contract
     * @param {ChainList} [chain] The chain to query
     * @param {string} [format] The format of the token id
     * @param {number} [offset] offset
     * @param {number} [limit] limit
     * @param {string} [order] The field(s) to order on and if it should be ordered in ascending or descending order. Specified by: fieldName1.order,fieldName2.order. Example 1: \&quot;block_number\&quot;, \&quot;block_number.ASC\&quot;, \&quot;block_number.DESC\&quot;, Example 2: \&quot;block_number and contract_type\&quot;, \&quot;block_number.ASC,contract_type.DESC\&quot;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getContractNFTTransfers(address: string, chain?: ChainList, format?: string, offset?: number, limit?: number, order?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<NftTransferCollection>;
    /**
     * Gets the contract level metadata (name, symbol, base token uri) for the given contract * Requests for contract addresses not yet indexed will automatically start the indexing process for that NFT collection
     * @summary Gets the global metadata for a given contract
     * @param {string} address Address of the contract
     * @param {ChainList} [chain] The chain to query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getNFTMetadata(address: string, chain?: ChainList, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<NftContractMetadata>;
    /**
     * Gets all owners of NFT items within a given contract collection * Use after /nft/contract/{token_address} to find out who owns each token id in a collection * Make sure to include a sort parm on a column like block_number_minted for consistent pagination results * Requests for contract addresses not yet indexed will automatically start the indexing process for that NFT collection
     * @summary Gets the owners of the NFTs of a given contract
     * @param {string} address Address of the contract
     * @param {ChainList} [chain] The chain to query
     * @param {string} [format] The format of the token id
     * @param {number} [offset] offset
     * @param {number} [limit] limit
     * @param {string} [order] The field(s) to order on and if it should be ordered in ascending or descending order. Specified by: fieldName1.order,fieldName2.order. Example 1: \&quot;name\&quot;, \&quot;name.ASC\&quot;, \&quot;name.DESC\&quot;, Example 2: \&quot;Name and Symbol\&quot;, \&quot;name.ASC,symbol.DESC\&quot;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getNFTOwners(address: string, chain?: ChainList, format?: string, offset?: number, limit?: number, order?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<NftOwnerCollection>;
    /**
     * Gets the amount which the spender is allowed to withdraw from the spender
     * @summary Gets the amount which the spender is allowed to withdraw from the owner.
     * @param {string} address The address of the token contract
     * @param {string} ownerAddress The address of the token owner
     * @param {string} spenderAddress The address of the token spender
     * @param {ChainList} [chain] The chain to query
     * @param {string} [providerUrl] web3 provider url to user when using local dev chain
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTokenAllowance(address: string, ownerAddress: string, spenderAddress: string, chain?: ChainList, providerUrl?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Erc20Allowance>;
    /**
     * Gets data, including metadata (where available), for the given token id of the given contract address. * Requests for contract addresses not yet indexed will automatically start the indexing process for that NFT collection
     * @summary Gets the NFT with the given id of a given contract
     * @param {string} address Address of the contract
     * @param {string} tokenId The id of the token
     * @param {ChainList} [chain] The chain to query
     * @param {string} [format] The format of the token id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTokenIdMetadata(address: string, tokenId: string, chain?: ChainList, format?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Nft>;
    /**
     * Gets all owners of NFT items within a given contract collection * Use after /nft/contract/{token_address} to find out who owns each token id in a collection * Make sure to include a sort parm on a column like block_number_minted for consistent pagination results * Requests for contract addresses not yet indexed will automatically start the indexing process for that NFT collection
     * @summary Gets the owners of NFTs for a given contract
     * @param {string} address Address of the contract
     * @param {string} tokenId The id of the token
     * @param {ChainList} [chain] The chain to query
     * @param {string} [format] The format of the token id
     * @param {number} [offset] offset
     * @param {number} [limit] limit
     * @param {string} [order] The field(s) to order on and if it should be ordered in ascending or descending order. Specified by: fieldName1.order,fieldName2.order. Example 1: \&quot;name\&quot;, \&quot;name.ASC\&quot;, \&quot;name.DESC\&quot;, Example 2: \&quot;Name and Symbol\&quot;, \&quot;name.ASC,symbol.DESC\&quot;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTokenIdOwners(address: string, tokenId: string, chain?: ChainList, format?: string, offset?: number, limit?: number, order?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<NftOwnerCollection>;
    /**
     * Returns metadata (name, symbol, decimals, logo) for a given token contract address.
     * @summary Gets token metadata
     * @param {Array<string>} addresses The addresses to get metadata for
     * @param {ChainList} [chain] The chain to query
     * @param {string} [subdomain] The subdomain of the moralis server to use (Only use when selecting local devchain as chain)
     * @param {string} [providerUrl] web3 provider url to user when using local dev chain
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTokenMetadata(addresses: Array<string>, chain?: ChainList, subdomain?: string, providerUrl?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Erc20Metadata>>;
    /**
     * Returns metadata (name, symbol, decimals, logo) for a given token contract address.
     * @summary Gets token metadata
     * @param {Array<string>} symbols The symbols to get metadata for
     * @param {ChainList} [chain] The chain to query
     * @param {string} [subdomain] The subdomain of the moralis server to use (Only use when selecting local devchain as chain)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTokenMetadataBySymbol(symbols: Array<string>, chain?: ChainList, subdomain?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Erc20Metadata>>;
    /**
     * Returns the price nominated in the native token and usd for a given token contract address.
     * @summary Gets token price
     * @param {string} address The address of the token contract
     * @param {ChainList} [chain] The chain to query
     * @param {string} [providerUrl] web3 provider url to user when using local dev chain
     * @param {string} [exchange] The factory name or address of the token exchange
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTokenPrice(address: string, chain?: ChainList, providerUrl?: string, exchange?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Erc20Price>;
    /**
     * Gets the transfers of the tokens matching the given parameters
     * @summary Gets NFT transfers of a given contract
     * @param {string} address Address of the contract
     * @param {string} tokenId The id of the token
     * @param {ChainList} [chain] The chain to query
     * @param {string} [format] The format of the token id
     * @param {number} [offset] offset
     * @param {number} [limit] limit
     * @param {string} [order] The field(s) to order on and if it should be ordered in ascending or descending order. Specified by: fieldName1.order,fieldName2.order. Example 1: \&quot;block_number\&quot;, \&quot;block_number.ASC\&quot;, \&quot;block_number.DESC\&quot;, Example 2: \&quot;block_number and contract_type\&quot;, \&quot;block_number.ASC,contract_type.DESC\&quot;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getWalletTokenIdTransfers(address: string, tokenId: string, chain?: ChainList, format?: string, offset?: number, limit?: number, order?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<NftTransferCollection>;
};
/**
 * TokenApi - factory interface
 * @export
 */
export declare const TokenApiFactory: (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) => {
    /**
     * Gets data, including metadata (where available), for all token ids for the given contract address. * Results are sorted by the block the token id was minted (descending) and limited to 100 per page by default * Requests for contract addresses not yet indexed will automatically start the indexing process for that NFT collection
     * @summary Retrieves the unique NFTs inside a given contract
     * @param {string} address Address of the contract
     * @param {ChainList} [chain] The chain to query
     * @param {string} [format] The format of the token id
     * @param {number} [offset] offset
     * @param {number} [limit] limit
     * @param {string} [order] If the order should be Ascending or Descending based on the blocknumber on which the NFT was minted. Allowed values: \&quot;ASC\&quot;, \&quot;DESC\&quot;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllTokenIds(address: string, chain?: ChainList, format?: string, offset?: number, limit?: number, order?: string, options?: any): Promise<NftCollection>;
    /**
     * Gets the transfers of the tokens matching the given parameters
     * @summary Gets NFT transfers of a given contract
     * @param {string} address Address of the contract
     * @param {ChainList} [chain] The chain to query
     * @param {string} [format] The format of the token id
     * @param {number} [offset] offset
     * @param {number} [limit] limit
     * @param {string} [order] The field(s) to order on and if it should be ordered in ascending or descending order. Specified by: fieldName1.order,fieldName2.order. Example 1: \&quot;block_number\&quot;, \&quot;block_number.ASC\&quot;, \&quot;block_number.DESC\&quot;, Example 2: \&quot;block_number and contract_type\&quot;, \&quot;block_number.ASC,contract_type.DESC\&quot;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getContractNFTTransfers(address: string, chain?: ChainList, format?: string, offset?: number, limit?: number, order?: string, options?: any): Promise<NftTransferCollection>;
    /**
     * Gets the contract level metadata (name, symbol, base token uri) for the given contract * Requests for contract addresses not yet indexed will automatically start the indexing process for that NFT collection
     * @summary Gets the global metadata for a given contract
     * @param {string} address Address of the contract
     * @param {ChainList} [chain] The chain to query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getNFTMetadata(address: string, chain?: ChainList, options?: any): Promise<NftContractMetadata>;
    /**
     * Gets all owners of NFT items within a given contract collection * Use after /nft/contract/{token_address} to find out who owns each token id in a collection * Make sure to include a sort parm on a column like block_number_minted for consistent pagination results * Requests for contract addresses not yet indexed will automatically start the indexing process for that NFT collection
     * @summary Gets the owners of the NFTs of a given contract
     * @param {string} address Address of the contract
     * @param {ChainList} [chain] The chain to query
     * @param {string} [format] The format of the token id
     * @param {number} [offset] offset
     * @param {number} [limit] limit
     * @param {string} [order] The field(s) to order on and if it should be ordered in ascending or descending order. Specified by: fieldName1.order,fieldName2.order. Example 1: \&quot;name\&quot;, \&quot;name.ASC\&quot;, \&quot;name.DESC\&quot;, Example 2: \&quot;Name and Symbol\&quot;, \&quot;name.ASC,symbol.DESC\&quot;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getNFTOwners(address: string, chain?: ChainList, format?: string, offset?: number, limit?: number, order?: string, options?: any): Promise<NftOwnerCollection>;
    /**
     * Gets the amount which the spender is allowed to withdraw from the spender
     * @summary Gets the amount which the spender is allowed to withdraw from the owner.
     * @param {string} address The address of the token contract
     * @param {string} ownerAddress The address of the token owner
     * @param {string} spenderAddress The address of the token spender
     * @param {ChainList} [chain] The chain to query
     * @param {string} [providerUrl] web3 provider url to user when using local dev chain
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTokenAllowance(address: string, ownerAddress: string, spenderAddress: string, chain?: ChainList, providerUrl?: string, options?: any): Promise<Erc20Allowance>;
    /**
     * Gets data, including metadata (where available), for the given token id of the given contract address. * Requests for contract addresses not yet indexed will automatically start the indexing process for that NFT collection
     * @summary Gets the NFT with the given id of a given contract
     * @param {string} address Address of the contract
     * @param {string} tokenId The id of the token
     * @param {ChainList} [chain] The chain to query
     * @param {string} [format] The format of the token id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTokenIdMetadata(address: string, tokenId: string, chain?: ChainList, format?: string, options?: any): Promise<Nft>;
    /**
     * Gets all owners of NFT items within a given contract collection * Use after /nft/contract/{token_address} to find out who owns each token id in a collection * Make sure to include a sort parm on a column like block_number_minted for consistent pagination results * Requests for contract addresses not yet indexed will automatically start the indexing process for that NFT collection
     * @summary Gets the owners of NFTs for a given contract
     * @param {string} address Address of the contract
     * @param {string} tokenId The id of the token
     * @param {ChainList} [chain] The chain to query
     * @param {string} [format] The format of the token id
     * @param {number} [offset] offset
     * @param {number} [limit] limit
     * @param {string} [order] The field(s) to order on and if it should be ordered in ascending or descending order. Specified by: fieldName1.order,fieldName2.order. Example 1: \&quot;name\&quot;, \&quot;name.ASC\&quot;, \&quot;name.DESC\&quot;, Example 2: \&quot;Name and Symbol\&quot;, \&quot;name.ASC,symbol.DESC\&quot;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTokenIdOwners(address: string, tokenId: string, chain?: ChainList, format?: string, offset?: number, limit?: number, order?: string, options?: any): Promise<NftOwnerCollection>;
    /**
     * Returns metadata (name, symbol, decimals, logo) for a given token contract address.
     * @summary Gets token metadata
     * @param {Array<string>} addresses The addresses to get metadata for
     * @param {ChainList} [chain] The chain to query
     * @param {string} [subdomain] The subdomain of the moralis server to use (Only use when selecting local devchain as chain)
     * @param {string} [providerUrl] web3 provider url to user when using local dev chain
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTokenMetadata(addresses: Array<string>, chain?: ChainList, subdomain?: string, providerUrl?: string, options?: any): Promise<Erc20Metadata[]>;
    /**
     * Returns metadata (name, symbol, decimals, logo) for a given token contract address.
     * @summary Gets token metadata
     * @param {Array<string>} symbols The symbols to get metadata for
     * @param {ChainList} [chain] The chain to query
     * @param {string} [subdomain] The subdomain of the moralis server to use (Only use when selecting local devchain as chain)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTokenMetadataBySymbol(symbols: Array<string>, chain?: ChainList, subdomain?: string, options?: any): Promise<Erc20Metadata[]>;
    /**
     * Returns the price nominated in the native token and usd for a given token contract address.
     * @summary Gets token price
     * @param {string} address The address of the token contract
     * @param {ChainList} [chain] The chain to query
     * @param {string} [providerUrl] web3 provider url to user when using local dev chain
     * @param {string} [exchange] The factory name or address of the token exchange
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTokenPrice(address: string, chain?: ChainList, providerUrl?: string, exchange?: string, options?: any): Promise<Erc20Price>;
    /**
     * Gets the transfers of the tokens matching the given parameters
     * @summary Gets NFT transfers of a given contract
     * @param {string} address Address of the contract
     * @param {string} tokenId The id of the token
     * @param {ChainList} [chain] The chain to query
     * @param {string} [format] The format of the token id
     * @param {number} [offset] offset
     * @param {number} [limit] limit
     * @param {string} [order] The field(s) to order on and if it should be ordered in ascending or descending order. Specified by: fieldName1.order,fieldName2.order. Example 1: \&quot;block_number\&quot;, \&quot;block_number.ASC\&quot;, \&quot;block_number.DESC\&quot;, Example 2: \&quot;block_number and contract_type\&quot;, \&quot;block_number.ASC,contract_type.DESC\&quot;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getWalletTokenIdTransfers(address: string, tokenId: string, chain?: ChainList, format?: string, offset?: number, limit?: number, order?: string, options?: any): Promise<NftTransferCollection>;
};
/**
 * TokenApi - object-oriented interface
 * @export
 * @class TokenApi
 * @extends {BaseAPI}
 */
export declare class TokenApi extends BaseAPI {
    /**
     * Gets data, including metadata (where available), for all token ids for the given contract address. * Results are sorted by the block the token id was minted (descending) and limited to 100 per page by default * Requests for contract addresses not yet indexed will automatically start the indexing process for that NFT collection
     * @summary Retrieves the unique NFTs inside a given contract
     * @param {string} address Address of the contract
     * @param {ChainList} [chain] The chain to query
     * @param {string} [format] The format of the token id
     * @param {number} [offset] offset
     * @param {number} [limit] limit
     * @param {string} [order] If the order should be Ascending or Descending based on the blocknumber on which the NFT was minted. Allowed values: \&quot;ASC\&quot;, \&quot;DESC\&quot;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokenApi
     */
    getAllTokenIds(address: string, chain?: ChainList, format?: string, offset?: number, limit?: number, order?: string, options?: any): Promise<NftCollection>;
    /**
     * Gets the transfers of the tokens matching the given parameters
     * @summary Gets NFT transfers of a given contract
     * @param {string} address Address of the contract
     * @param {ChainList} [chain] The chain to query
     * @param {string} [format] The format of the token id
     * @param {number} [offset] offset
     * @param {number} [limit] limit
     * @param {string} [order] The field(s) to order on and if it should be ordered in ascending or descending order. Specified by: fieldName1.order,fieldName2.order. Example 1: \&quot;block_number\&quot;, \&quot;block_number.ASC\&quot;, \&quot;block_number.DESC\&quot;, Example 2: \&quot;block_number and contract_type\&quot;, \&quot;block_number.ASC,contract_type.DESC\&quot;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokenApi
     */
    getContractNFTTransfers(address: string, chain?: ChainList, format?: string, offset?: number, limit?: number, order?: string, options?: any): Promise<NftTransferCollection>;
    /**
     * Gets the contract level metadata (name, symbol, base token uri) for the given contract * Requests for contract addresses not yet indexed will automatically start the indexing process for that NFT collection
     * @summary Gets the global metadata for a given contract
     * @param {string} address Address of the contract
     * @param {ChainList} [chain] The chain to query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokenApi
     */
    getNFTMetadata(address: string, chain?: ChainList, options?: any): Promise<NftContractMetadata>;
    /**
     * Gets all owners of NFT items within a given contract collection * Use after /nft/contract/{token_address} to find out who owns each token id in a collection * Make sure to include a sort parm on a column like block_number_minted for consistent pagination results * Requests for contract addresses not yet indexed will automatically start the indexing process for that NFT collection
     * @summary Gets the owners of the NFTs of a given contract
     * @param {string} address Address of the contract
     * @param {ChainList} [chain] The chain to query
     * @param {string} [format] The format of the token id
     * @param {number} [offset] offset
     * @param {number} [limit] limit
     * @param {string} [order] The field(s) to order on and if it should be ordered in ascending or descending order. Specified by: fieldName1.order,fieldName2.order. Example 1: \&quot;name\&quot;, \&quot;name.ASC\&quot;, \&quot;name.DESC\&quot;, Example 2: \&quot;Name and Symbol\&quot;, \&quot;name.ASC,symbol.DESC\&quot;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokenApi
     */
    getNFTOwners(address: string, chain?: ChainList, format?: string, offset?: number, limit?: number, order?: string, options?: any): Promise<NftOwnerCollection>;
    /**
     * Gets the amount which the spender is allowed to withdraw from the spender
     * @summary Gets the amount which the spender is allowed to withdraw from the owner.
     * @param {string} address The address of the token contract
     * @param {string} ownerAddress The address of the token owner
     * @param {string} spenderAddress The address of the token spender
     * @param {ChainList} [chain] The chain to query
     * @param {string} [providerUrl] web3 provider url to user when using local dev chain
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokenApi
     */
    getTokenAllowance(address: string, ownerAddress: string, spenderAddress: string, chain?: ChainList, providerUrl?: string, options?: any): Promise<Erc20Allowance>;
    /**
     * Gets data, including metadata (where available), for the given token id of the given contract address. * Requests for contract addresses not yet indexed will automatically start the indexing process for that NFT collection
     * @summary Gets the NFT with the given id of a given contract
     * @param {string} address Address of the contract
     * @param {string} tokenId The id of the token
     * @param {ChainList} [chain] The chain to query
     * @param {string} [format] The format of the token id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokenApi
     */
    getTokenIdMetadata(address: string, tokenId: string, chain?: ChainList, format?: string, options?: any): Promise<Nft>;
    /**
     * Gets all owners of NFT items within a given contract collection * Use after /nft/contract/{token_address} to find out who owns each token id in a collection * Make sure to include a sort parm on a column like block_number_minted for consistent pagination results * Requests for contract addresses not yet indexed will automatically start the indexing process for that NFT collection
     * @summary Gets the owners of NFTs for a given contract
     * @param {string} address Address of the contract
     * @param {string} tokenId The id of the token
     * @param {ChainList} [chain] The chain to query
     * @param {string} [format] The format of the token id
     * @param {number} [offset] offset
     * @param {number} [limit] limit
     * @param {string} [order] The field(s) to order on and if it should be ordered in ascending or descending order. Specified by: fieldName1.order,fieldName2.order. Example 1: \&quot;name\&quot;, \&quot;name.ASC\&quot;, \&quot;name.DESC\&quot;, Example 2: \&quot;Name and Symbol\&quot;, \&quot;name.ASC,symbol.DESC\&quot;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokenApi
     */
    getTokenIdOwners(address: string, tokenId: string, chain?: ChainList, format?: string, offset?: number, limit?: number, order?: string, options?: any): Promise<NftOwnerCollection>;
    /**
     * Returns metadata (name, symbol, decimals, logo) for a given token contract address.
     * @summary Gets token metadata
     * @param {Array<string>} addresses The addresses to get metadata for
     * @param {ChainList} [chain] The chain to query
     * @param {string} [subdomain] The subdomain of the moralis server to use (Only use when selecting local devchain as chain)
     * @param {string} [providerUrl] web3 provider url to user when using local dev chain
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokenApi
     */
    getTokenMetadata(addresses: Array<string>, chain?: ChainList, subdomain?: string, providerUrl?: string, options?: any): Promise<Erc20Metadata[]>;
    /**
     * Returns metadata (name, symbol, decimals, logo) for a given token contract address.
     * @summary Gets token metadata
     * @param {Array<string>} symbols The symbols to get metadata for
     * @param {ChainList} [chain] The chain to query
     * @param {string} [subdomain] The subdomain of the moralis server to use (Only use when selecting local devchain as chain)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokenApi
     */
    getTokenMetadataBySymbol(symbols: Array<string>, chain?: ChainList, subdomain?: string, options?: any): Promise<Erc20Metadata[]>;
    /**
     * Returns the price nominated in the native token and usd for a given token contract address.
     * @summary Gets token price
     * @param {string} address The address of the token contract
     * @param {ChainList} [chain] The chain to query
     * @param {string} [providerUrl] web3 provider url to user when using local dev chain
     * @param {string} [exchange] The factory name or address of the token exchange
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokenApi
     */
    getTokenPrice(address: string, chain?: ChainList, providerUrl?: string, exchange?: string, options?: any): Promise<Erc20Price>;
    /**
     * Gets the transfers of the tokens matching the given parameters
     * @summary Gets NFT transfers of a given contract
     * @param {string} address Address of the contract
     * @param {string} tokenId The id of the token
     * @param {ChainList} [chain] The chain to query
     * @param {string} [format] The format of the token id
     * @param {number} [offset] offset
     * @param {number} [limit] limit
     * @param {string} [order] The field(s) to order on and if it should be ordered in ascending or descending order. Specified by: fieldName1.order,fieldName2.order. Example 1: \&quot;block_number\&quot;, \&quot;block_number.ASC\&quot;, \&quot;block_number.DESC\&quot;, Example 2: \&quot;block_number and contract_type\&quot;, \&quot;block_number.ASC,contract_type.DESC\&quot;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokenApi
     */
    getWalletTokenIdTransfers(address: string, tokenId: string, chain?: ChainList, format?: string, offset?: number, limit?: number, order?: string, options?: any): Promise<NftTransferCollection>;
}
